<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="generator" content="Docusaurus">


<title data-react-helmet="true">How we migrate our framework into async/await</title>

<meta data-react-helmet="true" http-equiv="x-ua-compatible" content="ie=edge"><meta data-react-helmet="true" property="og:title" content="How we migrate our framework into async/await"><meta data-react-helmet="true" name="description" content="Firstly, congratulation on Rust lang achieving stable async/await syntax! As of the release, async/await is becoming the preferred way to do asynchronous programming instead of using Futures in Rust lang. "><meta data-react-helmet="true" property="og:description" content="Firstly, congratulation on Rust lang achieving stable async/await syntax! As of the release, async/await is becoming the preferred way to do asynchronous programming instead of using Futures in Rust lang. "><meta data-react-helmet="true" name="twitter:card" content="summary">

<link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico">


<link rel="stylesheet" href="/styles.f5d8eca1.css">

</head>
<body>

<div id="__docusaurus">
<nav class="navbar navbar--light navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a aria-current="page" class="navbar__brand active" href="/"><img class="navbar__logo"><strong>Obsidian</strong></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/docs/quick-start">Docs</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a><a class="navbar__item navbar__link" target="_blank" rel="noopener noreferrer" href="https://github.com/obsidian-rs/obsidian">GitHub</a></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a aria-current="page" class="navbar__brand active" href="/"><img class="navbar__logo"><strong>Obsidian</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/quick-start">Docs</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/blog">Blog</a></li><li class="menu__list-item"><a class="menu__link" target="_blank" rel="noopener noreferrer" href="https://github.com/obsidian-rs/obsidian">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="container margin-vert--xl"><div class="row"><div class="col col--8 col--offset-2"><article><header><h1 class="margin-bottom--sm blogPostTitle_2RZH">How we migrate our framework into async/await</h1><div class="margin-bottom--sm"><time datetime="2020-01-09T00:00:00.000Z" class="blogPostDate_3tRe">January 9, 2020</time></div><div class="avatar margin-bottom--md"><a class="avatar__photo-link" href="https://github.com/plwai" target="_blank" rel="noreferrer noopener"><img class="avatar__photo" src="https://avatars2.githubusercontent.com/u/9108726?s=460&amp;v=4" alt="Wai Pai Lee"></a><div class="avatar__intro"><h4 class="avatar__name"><a href="https://github.com/plwai" target="_blank" rel="noreferrer noopener">Wai Pai Lee</a></h4><small class="avatar__subtitle">Co-author of Obsidian</small></div></div></header><section class="markdown"><p>Firstly, congratulation on Rust lang achieving stable async/await syntax! As of the release, async/await is becoming the preferred way to do asynchronous programming instead of using Futures in Rust lang. </p><p>In Obsidian Web Framework, we do the same move just like other libraries which enabling async/await syntax in order to provide a better development experience.</p><p><em>*Rust 1.40 is used in this article</em></p><h1><a aria-hidden="true" tabindex="-1" class="anchor" id="in-case-you-dont-know-asyncawait-in-rust"></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#in-case-you-dont-know-asyncawait-in-rust" title="Direct link to heading">#</a>In case you don&#x27;t know async/await in Rust</h1><div align="center"><iframe width="560" height="315" src="https://www.youtube.com/embed/lJ3NC-R3gSI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><h1><a aria-hidden="true" tabindex="-1" class="anchor" id="why-asyncawait"></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#why-asyncawait" title="Direct link to heading">#</a>Why async/await?</h1><p><strong>Code complexity</strong>  -  You may design the code in the synchronous way. </p><p><strong>Readability</strong>  -  Avoid <code>and_then</code> and <code>then</code> chaining which making code hard to read. </p><p><strong>Lifetime</strong>  -  Lifetime is following synchronous flow within <code>async</code> function.</p><p>In Obsidian, we treat the developer&#x27;s development experience as the first priority goal. Thus, migration to async/await enabled structure is definitely needed.</p><h1><a aria-hidden="true" tabindex="-1" class="anchor" id="changing-futures-to-asyncawait"></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#changing-futures-to-asyncawait" title="Direct link to heading">#</a>Changing futures to async/await</h1><p>The process is pretty simple for most of the cases. Basically, we just add async to the function and remove <code>then</code> ,<code>and_then</code> and the dangerous <code>wait</code> to <code>await</code>. From the example below, it shows that the code is much cleaner and readable after using async/await.</p><p>from</p><pre class="mdxCodeBlock_iHAB"><div class="codeBlockWrapper_2QGZ"><pre class="prism-code language-rust codeBlock_19pQ" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">pub fn file(file_path: &amp;str) -&gt; ResponseResult {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    tokio_fs::file::File::open(file_path.to_string())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        .and_then(|file| {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            let buf: Vec&lt;u8&gt; = Vec::new();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            tokio_io::io::read_to_end(file, buf)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                .and_then(|item| {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    Ok(Response::builder()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        .status(StatusCode::OK)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        .body(item.1.into())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        .unwrap())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                })</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                .or_else(|_| {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    Ok(Response::builder()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        .status(StatusCode::INTERNAL_SERVER_ERROR)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        .body(Body::empty())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        .unwrap())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                })</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        })</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        .or_else(|err| {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            dbg!(&amp;err);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            Ok(Response::builder()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                .status(StatusCode::NOT_FOUND)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                .body(NOTFOUND.into())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                .unwrap())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        })</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        .wait()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button></div></pre><p>to</p><pre class="mdxCodeBlock_iHAB"><div class="codeBlockWrapper_2QGZ"><pre class="prism-code language-rust codeBlock_19pQ" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">pub async fn file(file_path: &amp;str) -&gt; ResponseResult {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    match fs::read(file_path.to_string()).await {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        Ok(buf) =&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            Ok(Response::builder()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                .status(StatusCode::OK)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                .body(buf.into())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                .unwrap())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        },</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        Err(err) =&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            Ok(Response::builder()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                .status(StatusCode::NOT_FOUND)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                .body(NOTFOUND.into())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                .unwrap())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        },</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button></div></pre><h1><a aria-hidden="true" tabindex="-1" class="anchor" id="using-asyncawait-in-trait-and-closure"></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#using-asyncawait-in-trait-and-closure" title="Direct link to heading">#</a>Using async/await in trait and closure</h1><p>In current Rust version, the <code>async</code> syntax does not support trait function and closure yet. It will be supported in the future. So, we need to do it another way around which is like this.</p><pre class="mdxCodeBlock_iHAB"><div class="codeBlockWrapper_2QGZ"><pre class="prism-code language-rust codeBlock_19pQ" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// trait</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">pub trait Middleware: Send + Sync + &#x27;static {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    fn handle&lt;&#x27;a&gt;(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &amp;&#x27;a self,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        context: Context,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ep_executor: EndpointExecutor&lt;&#x27;a&gt;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ) -&gt; std::pin::Pin&lt;Box&lt;dyn std::future::Future&lt;Output = Response&lt;Body&gt;&gt; + Send + &#x27;a&gt;&gt;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">impl Middleware for Logger {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    fn handle&lt;&#x27;a&gt;(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &amp;&#x27;a self,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        context: Context,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ep_executor: EndpointExecutor&lt;&#x27;a&gt;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ) -&gt; std::pin::Pin&lt;Box&lt;dyn std::future::Future&lt;Output = Response&lt;Body&gt;&gt; + Send + &#x27;a&gt;&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        let run = move |_self: &amp;Logger| async {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            println!(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                &quot;{} {} \n{}&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                context.method(),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                context.uri(),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                context.headers().get(&quot;host&quot;).unwrap().to_str().unwrap()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            ep_executor.next(context).await</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        Box::pin(run(self))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// closure</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">fn main() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // A closure which return async block instead of using async closure</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    let closure = || async {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        something().await</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button></div></pre><p>It seems complicated for a trait but luckily Rust community create a crate to simplify this which is called as <code>async-trait</code>. By using this crate, we are able to use traits with asyncsyntax!</p><pre class="mdxCodeBlock_iHAB"><div class="codeBlockWrapper_2QGZ"><pre class="prism-code language-rust codeBlock_19pQ" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#[async_trait]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">pub trait Middleware: Send + Sync + &#x27;static {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    async fn handle&lt;&#x27;a&gt;(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &amp;&#x27;a self,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        context: Context,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ep_executor: EndpointExecutor&lt;&#x27;a&gt;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ) -&gt; Response&lt;Body&gt;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#[async_trait]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">impl Middleware for Logger {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    async fn handle&lt;&#x27;a&gt;(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &amp;&#x27;a self,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        context: Context,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ep_executor: EndpointExecutor&lt;&#x27;a&gt;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ) -&gt; Response&lt;Body&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        println!(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            &quot;{} {} \n{}&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            context.method(),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            context.uri(),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            context.headers().get(&quot;host&quot;).unwrap().to_str().unwrap()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ep_executor.next(context).await</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button></div></pre><p>You may notice that this trait workaround method will result in a heap allocation per-function-call. So why do we use it? In Obsidian, we aim for delivering a better development experience. We believe that enabling await for traits like <code>Middleware</code> ease the development process. Besides that, we also trust the Rust community will enable the use of <code>async</code>  in trait soon. 😀</p><p>For more information on the trade-off, visit <a href="https://rust-lang.github.io/async-book/07_workarounds/06_async_in_traits.html">Asynchronous Programming in Rust</a> book.</p><h1><a aria-hidden="true" tabindex="-1" class="anchor" id="how-to-test-an-async-api"></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#how-to-test-an-async-api" title="Direct link to heading">#</a>How to test an async API?</h1><p>Sadly, now test function cannot use <code>async</code> syntax. Thus, we need to make it synchronous. In our framework, we use <code>async-std</code> task blocking feature to make it happen.</p><pre class="mdxCodeBlock_iHAB"><div class="codeBlockWrapper_2QGZ"><pre class="prism-code language-rust codeBlock_19pQ" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#[test]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">fn test_form() -&gt; Result&lt;(), ObsidianError&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    task::block_on(async {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        let params = HashMap::default();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        let request = Request::new(Body::from(&quot;id=1&amp;mode=edit&quot;));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        let mut ctx = Context::new(request, params);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        let actual_result: FormResult = ctx.form().await?;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        let expected_result = FormResult {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            id: 1,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            mode: &quot;edit&quot;.to_string(),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        assert_eq!(actual_result, expected_result);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        Ok(())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    })</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button></div></pre><h1><a aria-hidden="true" tabindex="-1" class="anchor" id="lifetime-issue"></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#lifetime-issue" title="Direct link to heading">#</a>Lifetime issue</h1><p>Although async/await seems perfect, it can be hard when dealing with <code>self</code> or struct outside of async block lifetime. In some cases, the developer might want to call an async implementation within the same struct. In this case, the compiler will not let you go. For instance:</p><pre class="mdxCodeBlock_iHAB"><div class="codeBlockWrapper_2QGZ"><pre class="prism-code language-rust codeBlock_19pQ" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">let service = make_service_fn(|_| {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    let server_clone = app_server.clone();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    async {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        Ok::&lt;_, hyper::Error&gt;(service_fn(move |req| {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            let server_clone = server_clone.clone();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            async move { Ok::&lt;_, hyper::Error&gt;(server_clone.resolve_endpoint(req).await) }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">});</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button></div></pre><p>The simplest way will be simply cloning the struct before async block call which is used above. However, the system will have the scalability issue. In Obsidian, the clone method decreased performance by ~25% with the sample of 1 endpoint router and 20 endpoint router. So, we decided to go for another approach by moving out the usage of <code>self</code> into synchronous part and move its ownership into the async block for the async process.</p><pre class="mdxCodeBlock_iHAB"><div class="codeBlockWrapper_2QGZ"><pre class="prism-code language-rust codeBlock_19pQ" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">let service = make_service_fn(|_| {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    let server_clone = app_server.clone();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    async {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        Ok::&lt;_, hyper::Error&gt;(service_fn(move |req| {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            let route_value = server_clone.router.search_route(req.uri().path());</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            AppServer::resolve_endpoint(req, route_value)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">});</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYj">Copy</button></div></pre><h1><a aria-hidden="true" tabindex="-1" class="anchor" id="about-obsidian"></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#about-obsidian" title="Direct link to heading">#</a>About Obsidian</h1><p><a href="https://github.com/obsidian-rs/obsidian">Obsidian</a> is a web development framework built in Rust which vision to lower down the learning curve of web development in Rust without losing the advantage of it. Currently, Obsidian is under active development and we expected to release v0.2 in this couple of months.</p></section><footer class="row margin-vert--lg"><div class="col"><strong>Tags:</strong><a class="margin-horiz--sm" href="/blog/tags/obsidian">obsidian</a><a class="margin-horiz--sm" href="/blog/tags/log">log</a></div></footer></article><div class="margin-vert--xl"><nav class="pagination-nav"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/blog/welcome"><h5 class="pagination-nav__link--sublabel">Next Post</h5><h4 class="pagination-nav__link--label">Welcome »</h4></a></div></nav></div></div></div></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/quick-start">Quick Start</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/doc1">Style Guide</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/doc2">Second Doc</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" target="_blank" rel="noopener noreferrer" href="https://stackoverflow.com/questions/tagged/docusaurus">Stack Overflow</a></li><li class="footer__item"><a class="footer__link-item" target="_blank" rel="noopener noreferrer" href="https://discordapp.com/invite/docusaurus">Discord</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Social</h4><ul class="footer__items"><li class="footer__item"><a aria-current="page" class="footer__link-item active" href="/blog">Blog</a></li><li class="footer__item"><a class="footer__link-item" target="_blank" rel="noopener noreferrer" href="https://github.com/facebook/docusaurus">GitHub</a></li><li class="footer__item"><a class="footer__link-item" target="_blank" rel="noopener noreferrer" href="https://twitter.com/docusaurus">Twitter</a></li></ul></div></div><div class="text--center">Copyright © 2020 My Project, Inc. Built with Docusaurus.</div></div></footer>
</div>

<script src="/styles.5f3ad418.js"></script>

<script src="/runtime~main.2e7cdedb.js"></script>

<script src="/main.ff06fa77.js"></script>

<script src="/1.674492b1.js"></script>

<script src="/2.8f502995.js"></script>

<script src="/ccc49370.50917f23.js"></script>

<script src="/275a1e45.859da0d1.js"></script>


</body>
</html>