---
id: obsidian-v0.2
title: Announcing Obsidian 0.2 
author: Gan Jun Kai 
author_title: Co-author of Obsidian
author_url: https://github.com/jk-gan
author_image_url: https://avatars3.githubusercontent.com/u/7545747?s=460&u=ecd6fc8fcb20d3913c42489a1cbc9c1a5cb1aec0&v=4
draft: true
tags: [obsidian, release]
---

After months of hard work from the team, we are proud to announce the release of Obsidian version 0.2. This release included a lot of features to improve Obsidian's user experience. This blog post covers the highlights of the release.

Obsidian is a Rust async http framework for amazing, reliable and efficient web. 

<!--truncate-->

## New Logo!
<figure>
  <img width="550" src="/blog/assets/obsidian.svg" alt="Screenshot of Obsidian logo" />
</figure>

We now have a logo!

## Async/Await Support
In Obsidian, we treat the developer's development experience as the first priority goal. Thus, migration to async/await enabled structure is definitely needed.

```rust
async fn get_user(ctx: Context) -> ContextResult {

}
```

## Application State
Application state is shared with all the routes. It can be accessed by handlers and middlewares. You can inject your database connection in to application state.

```rust
use obsidian::{context::Context, App, ObsidianError};

#[derive(Clone)]
pub struct AppState {
    pub db_connection_string: String,
}

#[tokio::main]
async fn main() {
    let mut app: App<AppState> = App::new();
    let addr = ([127, 0, 0, 1], 3000).into();

    app.set_app_state(AppState {
        db_connection_string: "localhost:1433".to_string()
    });

    app.get("/", |ctx: Context| async { 
        let app_state = ctx.get::<AppState>().ok_or(ObsidianError::NoneError)?;
        let res = Some(format!("connection string: {}", &app_state.db_connection_string));

        ctx.build(res).ok() 
    });

    app.listen(&addr, || {
        println!("server is listening to {}", &addr);
    })
    .await;
}
```

## Custom Header
```rust
async fn get_point(ctx: Context) -> ContextResult {
    let point = Point { x: 1, y: 2 };

    ctx.build(
        Response::created()
            .set_header(header::AUTHORIZATION, "token")
            .set_header_str("X-Custom-Header", "Custom header value")
            .json(point),
    )
    .ok()
}
```

## Dynamic Context data

## What is next?

