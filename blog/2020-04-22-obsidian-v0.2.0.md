---
id: obsidian-v0.2
title: Announcing Obsidian 0.2
author: Gan Jun Kai
author_title: Co-author of Obsidian
author_url: https://github.com/jk-gan
author_image_url: https://avatars3.githubusercontent.com/u/7545747?s=460&u=ecd6fc8fcb20d3913c42489a1cbc9c1a5cb1aec0&v=4
tags: [obsidian, release]
---

After months of hard work from the team, we are proud to announce the release of Obsidian version 0.2. This release included a lot of features to improve Obsidian's developer experience. This blog post covers the highlights of the release.

Obsidian is a Rust async http framework for amazing, reliable and efficient web.

<!--truncate-->

## New Logo!

<figure>
  <img width="550" src="/blog/assets/obsidian.svg" alt="Screenshot of Obsidian logo" />
</figure>

We now have a logo!

## Async/Await Support
Rust 1.39.0 introduced `async`/`.await` syntax, which can be used to write asynchronous funtion in synchronous way. It also makes the codes more straight forward. In Obsidian, we treat the developer experience as the first priority goal. Thus, migration to async/await enabled structure is definitely needed.

```rust
async fn get_user(mut ctx: Context) -> ContextResult {
    #[derive(Serialize, Deserialize)]
    struct User {
        name: String,
        age: i8,
    }

    let user: User = ctx.json().await?;

    ctx.build_json(user).ok()
}
```

## Application State

Application state is shared with all the routes. It can be accessed by handlers and middlewares. You can inject your database connection in to application state.

```rust
use obsidian::{context::Context, App, ObsidianError};

#[derive(Clone)]
pub struct AppState {
    pub db_connection_string: String,
}

#[tokio::main]
async fn main() {
    let mut app: App<AppState> = App::new();
    let addr = ([127, 0, 0, 1], 3000).into();

    app.set_app_state(AppState {
        db_connection_string: "localhost:1433".to_string()
    });

    app.get("/", |ctx: Context| async {
        let app_state = ctx.get::<AppState>().ok_or(ObsidianError::NoneError)?;
        let res = Some(format!("connection string: {}", &app_state.db_connection_string));

        ctx.build(res).ok()
    });

    app.listen(&addr, || {
        println!("server is listening to {}", &addr);
    })
    .await;
}
```

## Response Header
You now can return a response with headers. And did I mention custom headers is supported as well?  

```rust
async fn get_point(ctx: Context) -> ContextResult {
    let point = Point { x: 1, y: 2 };

    ctx.build(
        Response::created()
            .set_header(header::AUTHORIZATION, "token")
            .set_header_str("X-Custom-Header", "Custom header value")
            .json(point),
    )
    .ok()
}
```

## Dynamic Context data

## What is next?
As we mentioned, developer experience and productivity are always our top priority in `Obsidian`. We always have the convesation on improving most of the confusing API and syntax noise.

There are some API redesign will be introduced on the next version to improve developer experience. And we are planning to provide generator to generate new `Obsidian` project. We don't have final a decision yet, it could be just a boilerplate like [`create-react-app`](https://create-react-app.dev/) but for backend, or something like [`rails`](https://rubyonrails.org/) and [`phoenix`](https://www.phoenixframework.org/) with **convention over configuration** setup to ease developer's jobs. This will include database connection config by default because we found that setup database connection everytime for a new project is quite annoying. We want to let our users focus on the important stuffs without sweating the small things.

According to [Rust 2019 survey](https://blog.rust-lang.org/2020/04/17/Rust-survey-2019.html), productivity is still an important goal for their work. Most of the developers in the survey, with Rust or without Rust, are working on backend application. Therefore we think we are on the right track. We want to build a framework we will enjoy using it everyday. 
