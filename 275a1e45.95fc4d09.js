(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{108:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return r})),t.d(n,"metadata",(function(){return s})),t.d(n,"rightToc",(function(){return c})),t.d(n,"default",(function(){return u}));var a=t(1),o=t(6),i=(t(0),t(130)),r={id:"async-migrate",title:"How we migrate our framework into async/await",author:"Wai Pai Lee",author_title:"Co-author of Obsidian",author_url:"https://github.com/plwai",author_image_url:"https://avatars2.githubusercontent.com/u/9108726?s=460&v=4",tags:["obsidian","log"]},s={permalink:"/blog/async-migrate",source:"@site/blog/2020-01-09-async-migrate.md",description:"Firstly, congratulation on Rust lang achieving stable async/await syntax! As of the release, async/await is becoming the preferred way to do asynchronous programming instead of using Futures in Rust lang.\xa0",date:"2020-01-09T00:00:00.000Z",tags:[{label:"obsidian",permalink:"/blog/tags/obsidian"},{label:"log",permalink:"/blog/tags/log"}],title:"How we migrate our framework into async/await",readingTime:4.42,truncated:!0,prevItem:{title:"Announcing Obsidian 0.2",permalink:"/blog/obsidian-v0.2"}},c=[],l={rightToc:c};function u(e){var n=e.components,t=Object(o.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},l,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Firstly, congratulation on Rust lang achieving stable async/await syntax! As of the release, async/await is becoming the preferred way to do asynchronous programming instead of using Futures in Rust lang.\xa0"),Object(i.b)("p",null,"In Obsidian Web Framework, we do the same move just like other libraries which enabling async/await syntax in order to provide a better development experience."),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},"*Rust 1.40 is used in this article")),Object(i.b)("h1",{id:"in-case-you-dont-know-asyncawait-in-rust"},"In case you don't know async/await in\xa0Rust"),Object(i.b)("div",{align:"center"},Object(i.b)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/lJ3NC-R3gSI",frameborder:"0",allow:"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0})),Object(i.b)("h1",{id:"why-asyncawait"},"Why async/await?"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Code complexity")," \u200a- \u200aYou may design the code in the synchronous way.\xa0"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Readability"),"\u200a - \u200aAvoid ",Object(i.b)("inlineCode",{parentName:"p"},"and_then")," and ",Object(i.b)("inlineCode",{parentName:"p"},"then")," chaining which making code hard to read.\xa0"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Lifetime"),"\u200a - \u200aLifetime is following synchronous flow within ",Object(i.b)("inlineCode",{parentName:"p"},"async")," function."),Object(i.b)("p",null,"In Obsidian, we treat the developer's development experience as the first priority goal. Thus, migration to async/await enabled structure is definitely needed."),Object(i.b)("h1",{id:"changing-futures-to-asyncawait"},"Changing futures to async/await"),Object(i.b)("p",null,"The process is pretty simple for most of the cases. Basically, we just add async to the function and remove ",Object(i.b)("inlineCode",{parentName:"p"},"then"),"\xa0,",Object(i.b)("inlineCode",{parentName:"p"},"and_then")," and the dangerous ",Object(i.b)("inlineCode",{parentName:"p"},"wait")," to ",Object(i.b)("inlineCode",{parentName:"p"},"await"),". From the example below, it shows that the code is much cleaner and readable after using async/await."),Object(i.b)("p",null,"from"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),"pub fn file(file_path: &str) -> ResponseResult {\n    tokio_fs::file::File::open(file_path.to_string())\n        .and_then(|file| {\n            let buf: Vec<u8> = Vec::new();\n            tokio_io::io::read_to_end(file, buf)\n                .and_then(|item| {\n                    Ok(Response::builder()\n                        .status(StatusCode::OK)\n                        .body(item.1.into())\n                        .unwrap())\n                })\n                .or_else(|_| {\n                    Ok(Response::builder()\n                        .status(StatusCode::INTERNAL_SERVER_ERROR)\n                        .body(Body::empty())\n                        .unwrap())\n                })\n        })\n        .or_else(|err| {\n            dbg!(&err);\n            Ok(Response::builder()\n                .status(StatusCode::NOT_FOUND)\n                .body(NOTFOUND.into())\n                .unwrap())\n        })\n        .wait()\n}\n")),Object(i.b)("p",null,"to"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),"pub async fn file(file_path: &str) -> ResponseResult {\n    match fs::read(file_path.to_string()).await {\n        Ok(buf) => {\n            Ok(Response::builder()\n                .status(StatusCode::OK)\n                .body(buf.into())\n                .unwrap())\n        },\n        Err(err) => {\n            Ok(Response::builder()\n                .status(StatusCode::NOT_FOUND)\n                .body(NOTFOUND.into())\n                .unwrap())\n        },\n    }\n}\n")),Object(i.b)("h1",{id:"using-asyncawait-in-trait-and-closure"},"Using async/await in\xa0trait and closure"),Object(i.b)("p",null,"In current Rust version, the ",Object(i.b)("inlineCode",{parentName:"p"},"async")," syntax does not support trait function and closure yet. It will be supported in the future. So, we need to do it another way around which is like this."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),"// trait\npub trait Middleware: Send + Sync + 'static {\n    fn handle<'a>(\n        &'a self,\n        context: Context,\n        ep_executor: EndpointExecutor<'a>,\n    ) -> std::pin::Pin<Box<dyn std::future::Future<Output = Response<Body>> + Send + 'a>>;\n}\n\nimpl Middleware for Logger {\n    fn handle<'a>(\n        &'a self,\n        context: Context,\n        ep_executor: EndpointExecutor<'a>,\n    ) -> std::pin::Pin<Box<dyn std::future::Future<Output = Response<Body>> + Send + 'a>> {\n        let run = move |_self: &Logger| async {\n            println!(\n                \"{} {} \\n{}\",\n                context.method(),\n                context.uri(),\n                context.headers().get(\"host\").unwrap().to_str().unwrap()\n            );\n\n            ep_executor.next(context).await\n        };\n\n        Box::pin(run(self))\n    }\n}\n\n// closure\nfn main() {\n    // A closure which return async block instead of using async closure\n    let closure = || async {\n        something().await\n    }\n}\n")),Object(i.b)("p",null,"It seems complicated for a trait but luckily Rust community create a crate to simplify this which is called as ",Object(i.b)("inlineCode",{parentName:"p"},"async-trait"),". By using this crate, we are able to use traits with asyncsyntax!"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),"#[async_trait]\npub trait Middleware: Send + Sync + 'static {\n    async fn handle<'a>(\n        &'a self,\n        context: Context,\n        ep_executor: EndpointExecutor<'a>,\n    ) -> Response<Body>;\n}\n\n#[async_trait]\nimpl Middleware for Logger {\n    async fn handle<'a>(\n        &'a self,\n        context: Context,\n        ep_executor: EndpointExecutor<'a>,\n    ) -> Response<Body> {\n        println!(\n            \"{} {} \\n{}\",\n            context.method(),\n            context.uri(),\n            context.headers().get(\"host\").unwrap().to_str().unwrap()\n        );\n\n        ep_executor.next(context).await\n    }\n}\n")),Object(i.b)("p",null,"You may notice that this trait workaround method will result in a heap allocation per-function-call. So why do we use it? In Obsidian, we aim for delivering a better development experience. We believe that enabling await for traits like ",Object(i.b)("inlineCode",{parentName:"p"},"Middleware")," ease the development process. Besides that, we also trust the Rust community will enable the use of ",Object(i.b)("inlineCode",{parentName:"p"},"async"),"  in trait soon. \ud83d\ude00"),Object(i.b)("p",null,"For more information on the trade-off, visit ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://rust-lang.github.io/async-book/07_workarounds/06_async_in_traits.html"}),"Asynchronous Programming in Rust")," book."),Object(i.b)("h1",{id:"how-to-test-an-async-api"},"How to test an async API?"),Object(i.b)("p",null,"Sadly, now test function cannot use ",Object(i.b)("inlineCode",{parentName:"p"},"async")," syntax. Thus, we need to make it synchronous. In our framework, we use ",Object(i.b)("inlineCode",{parentName:"p"},"async-std")," task blocking feature to make it happen."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),'#[test]\nfn test_form() -> Result<(), ObsidianError> {\n    task::block_on(async {\n        let params = HashMap::default();\n        let request = Request::new(Body::from("id=1&mode=edit"));\n\n        let mut ctx = Context::new(request, params);\n\n        let actual_result: FormResult = ctx.form().await?;\n        let expected_result = FormResult {\n            id: 1,\n            mode: "edit".to_string(),\n        };\n\n        assert_eq!(actual_result, expected_result);\n        Ok(())\n    })\n}\n')),Object(i.b)("h1",{id:"lifetime-issue"},"Lifetime issue"),Object(i.b)("p",null,"Although async/await seems perfect, it can be hard when dealing with ",Object(i.b)("inlineCode",{parentName:"p"},"self")," or struct outside of async block lifetime. In some cases, the developer might want to call an async implementation within the same struct. In this case, the compiler will not let you go. For instance:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),"let service = make_service_fn(|_| {\n    let server_clone = app_server.clone();\n    async {\n        Ok::<_, hyper::Error>(service_fn(move |req| {\n            let server_clone = server_clone.clone();\n            async move { Ok::<_, hyper::Error>(server_clone.resolve_endpoint(req).await) }\n        }))\n    }\n});\n")),Object(i.b)("p",null,"The simplest way will be simply cloning the struct before async block call which is used above. However, the system will have the scalability issue. In Obsidian, the clone method decreased performance by ~25% with the sample of 1 endpoint router and 20 endpoint router. So, we decided to go for another approach by moving out the usage of ",Object(i.b)("inlineCode",{parentName:"p"},"self")," into synchronous part and move its ownership into the async block for the async process."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),"\nlet service = make_service_fn(|_| {\n    let server_clone = app_server.clone();\n    async {\n        Ok::<_, hyper::Error>(service_fn(move |req| {\n            let route_value = server_clone.router.search_route(req.uri().path());\n            AppServer::resolve_endpoint(req, route_value)\n        }))\n    }\n});\n")),Object(i.b)("h1",{id:"about-obsidian"},"About Obsidian"),Object(i.b)("p",null,Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/obsidian-rs/obsidian"}),"Obsidian")," is a web development framework built in Rust which vision to lower down the learning curve of web development in Rust without losing the advantage of it. Currently, Obsidian is under active development and we expected to release v0.2 in this couple of months."))}u.isMDXComponent=!0}}]);